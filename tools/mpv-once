#!/bin/bash
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
. $DIR/lib.sh

player=mpv
player_opts='--no-cache --no-audio-display --msg-level=cplayer=no --term-playing-msg=\n${media-title} --script='"$DIR"'/quit-on-error.lua --input-ipc-server=/tmp/mpvsocket'
display=0
playlist_get=1
nopl=
auto=

[[ -e $DIR/prefs.sh ]] && . $DIR/prefs.sh

# We're going to restore it to this.
start_name=$( tmux display-message -p '#W' )
start_dir=$(pwd)
start_time=0:45

ao=${ao:-pulse}
day=86400

shopt -s nullglob

#tmux rename-window "mpv-once" 2> /dev/null

function finish {
  tmux rename-window "$start_name"
  exit
}
function headline {
  echo -e "\t$1" | tr '[a-z]' '[A-Z]'
}

function status {
  [[ -n "$2" ]] && echo
  echo -e "\t\t$1"
}

trap finish EXIT

# This allows remote control
#if [[ -n "$1" ]]; then
#  mpv $1/*mp3
#  exit
#fi

filter=.
if [[ $# -gt 0 ]]; then
  filter="($1"
  shift
  while [[ $# -gt 0 ]]; do
    filter="${filter}|${1}"
    shift
  done
  filter="$filter)"
fi

function record_listen() {
  if [[ "$n" != "__nothing" ]]; then 
    cp .listen_done /tmp/.listen_done-$(date +%Y%m%d%H%M%S)

    # Remove any previous record of this
    st=$( echo "$i" | tr '//' '.' )
    sed -i "/$st/d" .listen_done

    echo "$i $n (time:$listen_time) $(date +%Y%m%d)" >> .listen_done
  fi
}

function playit() {
  $player --ao=$ao $player_opts \
    --term-playing-msg=" \${playlist-pos-1}\t\${media-title}" \
    --term-status-msg="\t\${audio-pts} - \${duration}\n" \
    --start=$start_time \
    $*
}

echo */* | tr ' ' '\n' > .listen_all
touch .listen_done
all=( $(cat .listen_all .listen_done | grep -E "$filter" | awk ' { print $1 } ' | sort | uniq -u | shuf) )
size=${#all[@]}
ix=0 

for i in ${all[@]}; do

  tmux rename-window "mpv-once" 2> /dev/null
  (( ix ++ ))
  n="__nothing"
  listen_time=0

  if [[ ! -d "$i" ]]; then
    status "Gone - $i"
    n="__purge"
    record_listen
    continue
  fi

  ls "$i"/*.mp3 "$i"/*.aiff > /dev/null 2>&1
  if [[ $? == "0" || -e "$i/$PLAYLIST" ]]; then

    attempts=0
    while [[ 0 ]]; do
    tabs 2,+2
      if [[ -e "$i/domain" ]]; then
        url=$(< "$i/domain" )
      else
        label=$( dirname "$i" )
        [[ -e $label/domain ]] && domain=$(< $label/domain ) || domain=${label}.bandcamp.com
        release=$( basename "$i" )
        url="https://$domain/album/$release"
      fi

      printf "\n%11s - %s\n%11s - %s\n" "$ix / $size" "$start_dir/$i" "" "$url"

      list="$i/*.mp3 $i/*.aiff"
      m3u="$i/$PLAYLIST"
      fileList=( $list )

      if [[ -e "$m3u" ]]; then
        ttl=$(grep -c $PLAYLIST "$m3u")
        if [[ $ttl != 0 ]]; then
          status "Bogus m3u ! deleting"
          rm "$m3u"
        fi
      fi

      if [[ ! -e "$m3u" && ! -e "$i"/no-files && -n "$playlist_get" ]]; then
        status "Getting - $m3u"
        pushd "$i" > /dev/null
        get_playlist "$url"
        popd > /dev/null
      fi

      if [[ -s "$m3u" && -z "$nopl" ]]; then
        playlistIsRemote=$(grep -i http $m3u)
        while [[ 0 ]]; do

          before=$( date +%s )
          age=$(( $before - $(stat -c %Y "$m3u") ))

          if [[ -z "$playlistIsRemote" || $age -lt $day ]]; then
            
            t_count=$(cat "$m3u" | wc -l)
            echo
            [[ $t_count != 1 ]] && echo -e " \033[1m$(cat "$m3u" | wc -l) TRACKS\033[0m"

            playit "$m3u"
            player_exit=$?
            (( listen_time += $(date +%s) - before ))
            status "Time - $listen_time\n"
          else
            # If our m3u is over a day old we just
            # assume failure
            status "m3u age: $(( age / day ))d"
            player_exit=2
          fi

          if [[ $player_exit == "2" ]]; then
            status "Woops, need to get a new set of urls"
            if [[ $attempts -gt 2 ]]; then
              status "This isn't going that well"
              break
            fi
            get_urls "$url" "$i"
            (( attempts ++ ))
            continue
          fi
          break
        done
      elif (( ${#fileList[@]} )); then

        before=$( date +%s )
          
        $player --ao=$ao $player_opts \
          --term-playing-msg=" \${playlist-pos-1}\t\${media-title}" \
          --term-status-msg="\t\${audio-pts} - \${duration}\n" \
          --start=$start_time \
          "$i"/*.mp3

        (( listen_time += $(date +%s) - before ))

        echo -e "\tTime - $listen_time\n"
      elif [[ -e "$i"/no-files ]]; then

        headline "No files"
        ls -ltr "$i"  |  sed 's/^/\t/'
        n='pu'
        break
      else
        if [[ -n "$LOCAL" ]]; then
          status "No local files, skipping"
          n="sn"
          break
        fi

        # only do a single download/play loop attempt
        if [[ -z "$auto" ]]; then
          status "I'll try to download things again" nl
          get_mp3s "$url" "$i"
          auto=1
          continue
        else
          status "Not trying that again!"
        fi

      fi

      while [[ 0 ]]; do
        read -p "[[1m$i[0m] " -e n
        if [[ $n == 'i' ]]; then 
          {
          echo
          echo $url
          echo $start_dir/$i
          echo "playlist_get=$playlist_get"
          echo
          }  |  sed 's/^/    /'
        fi

        if [[ ${n:0:2} == 'ao' ]]; then
          ao=${n:3}
          status "Setting audio out to '$ao'"
          [[ -e $DIR/prefs.sh ]] && sed -Ei 's/ao=.*/ao='$ao'/g' $DIR/prefs.sh

        elif [[ ${n:0:2} == 'b ' ]]; then
          start_time=${n:2}
          status "Setting start time to $start_time"

        elif [[ $n == 'l' ]]; then
          echo
          if [[ -s "$m3u" ]]; then
            headline "playlist" 
            cat $m3u | sed 's/^/\t/'
            echo
          fi

          headline "files"
          ls -l "$i" | sed 's/^/\t/'
          echo
        fi

        if [[ $n == '?' ]]; then
          headline "help" 
          { cat <<- ENDL
          ?       - This help page
          !       - Do a \$SHELL here
          3,4,5   - Rate
          dl      - Download the files
          dlp     - Download just the playlist
          i       - Info of the album
          l       - List the files
          pu      - Purge (delete)
          r       - Repeat
          r nopl  - Repeat (ignore playlist)
          s       - Skip (and log)
          sn      - Skip (but do not log)
          x       - Exit

          FLAGS:

          pl      - Download the playlist
          nopl    - Do not download the playlist

          ao[...] - Set the audio out to [...]
          b[...]  - Set the start time to [...]

          debug   - Enable debugging
          nodebug - Turn off debugging

	ENDL
        } | sed 's/^\s*/    /g';
        elif [[ $n == 'nopl' ]]; then
          status "Skipping playlist downloads"
          playlist_get=

        elif [[ $n == 'pl' ]]; then
          status "Playlist on"
          playlist_get=1

        elif [[ $n == 'nodebug' ]]; then
          status "Turning off verbose output"
          set +x

        elif [[ $n == 'debug' ]]; then
          echo $PWD
          set -x

        elif [[ $n == '!' ]]; then 
          (
            cd "$i"
            $SHELL
          )
        elif [[ $n == 'dlp' ]]; then 
          (
            status "Downloading playlist"
            cd "$i"
            get_playlist "$url"
          )
        elif [[ $n == 'dl' ]]; then 
          get_mp3s "$url" "$i"
        fi
        if [[ "$n" == 'r nopl' ]]; then
          status "Ignoring playlist"
          nopl=1
        fi
        [[ "$n" =~ ^(x|r|s|sn|[1-5]|pu)$ ]] && break
      done

      [[ $n == 'x' ]] && exit
      [[ $n == 'r' ]] || break
    done

    if [[ $n == 'pu' ]]; then 

      $DIR/album-purge "$i" $start_dir
      n="__purge"
    elif [[ $n == 'sn' ]]; then

      status "Skipping - not recording"
      n="__nothing"
    elif [[ $n == 's' ]]; then

      status "Skipping"
      n="__skipping"
    else
      n="__rating_$n"
    fi
  fi
  # The repeat while ignoring playlist is a one-time
  # flag that has to be set the next time
  nopl=
  auto=
  record_listen
done
